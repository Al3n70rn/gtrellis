<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Analyze genomic regions}
-->

Make genome-level plots in Trellis style
======================================

**Author**: Zuguang Gu ( z.gu@dkfz.de )

**Date**: `r Sys.time()`


```{r, echo = FALSE, message = FALSE}
library(knitr)
knitr::opts_chunk$set(
    error = FALSE,
    tidy  = FALSE,
    message = FALSE,
    fig.align = "center")

options(width = 100)
```

[Trellis graph](https://www.stat.auckland.ac.nz/~ihaka/787/lectures-trellis.pdf) 
is a type of graphic which splices data by category and visualize 
subset of data in each category parallel. For genomic data, chromosomes are always 
the category variable. In R, **lattice** and **ggplot2** can make trellis graphic, 
however, specially for whole genome plot, they are limited in:

- Chromosomes have different length. But in **lattice**/**ggplot2**, panel width
  for each chromosome are the same, so short chromosomes will be extended with 
  empty region which sometimes is a waste of space.
- Genomic data are more multiple dimensional, which means, there are always more 
  than one tracks for chromosomes that to be compared.
- **ggbio** also supports trellis visualizatioin for the whole genome, but still,
  only one track is supported. (for continuous region, multiple tracks are supported
  in **ggbio**.) 

Here, **gtrellis** aims to arrange chromosomes as trellis style and support multiple
tracks for visualization. **gtrellis** is implemented in **grid** graphic system.

## Initialize the layout

Call `initialize_layout()` with default parameters. By default, it initializes the layout
with hg19 and puts all chromosomes in one row. Each chromosome has only one track and 
range on y-axis is 0 to 1.

In the layout which is generated by **gtrellis**, first, it arrange chromosomes as trellis 
style. For each chromosome, the region is split into several tracks. Each track in one
chromosome is called a 'cell' in this vignette.

```{r, fig.width = 10, fig.height = 6}
library(gtrellis)
initialize_layout()
```

Select subset of chromosomes and use `add_cell_info()` to add the information of each cell.

```{r, fig.width = 6, fig.height = 6}
initialize_layout(chromosome = c("chr1", "chr3"))
add_cell_info()
```

Use other species:

```{r, fig.width = 10, fig.height = 6}
initialize_layout(species = "mm10")
```

Number of rows or columns to arrange the layout:

```{r, fig.width = 8, fig.height = 8}
initialize_layout(nrow = 3)
add_cell_info()
initialize_layout(ncol = 5)
add_cell_info()
```

Order of chromosomes. In following figure, since chromosome X is much longer
than other chromosomes in the last column, the last column is wider than
its left column.

```{r, fig.width = 8, fig.height = 8}
initialize_layout(ncol = 5, byrow = FALSE)
add_cell_info()
```

Make all columns having equal width, then all chromosomes share the same range
on x-axis and short chromosomes will be extended with empty regions.

```{r, fig.width = 10, fig.height = 6}
initialize_layout(equal_width = TRUE)
```

Make all columns having equal width and also set multiple rows

```{r, fig.width = 8, fig.height = 8}
initialize_layout(ncol = 5, byrow = FALSE, equal_width = TRUE)
add_cell_info()
```

Set gap between chromosomes. Note if it is set as numeric value,
it must only be 0.

```{r, fig.width = 10, fig.height = 6, fig.keep = "all"}
initialize_layout(gap = 0)
```

`gap` can be a `unit` object

```{r, fig.width = 10, fig.height = 6, fig.keep = "all"}
initialize_layout(gap = unit(5, "mm"))
```

If `gap` is length of two, the first one corresponds to the gap between rows
and the second corresponds to the gap between columns

```{r, fig.width = 8, fig.height = 8}
initialize_layout(ncol = 5, gap = unit(c(5, 2), "mm"))
```

Set number of tracks:

```{r, fig.width = 10, fig.height = 6}
initialize_layout(track_number = 3)
```

Height of tracks. If it is set as numeric values, it will be normalized
as ratio to the sum.

```{r, fig.width = 10, fig.height = 6}
initialize_layout(track_number = 3, track_height = c(1, 2, 3))
```

Height can also be `unit` object

```{r, fig.width = 10, fig.height = 6}
initialize_layout(track_number = 3, 
    track_height = unit.c(unit(1, "cm"), unit(1, "null"), grobHeight(textGrob("chr1"))))
```

Whether show y-axes. If certain value is set to `FALSE`, corresponding track y-axis
will not be added.

```{r, fig.width = 10, fig.height = 6}
initialize_layout(track_number = 3, track_axis = c(FALSE, FALSE, FALSE), xaxis = FALSE)
```

Set y-lim. It should be a two-column matrix, but to make it easy, it can
also be a vector and it will be filled into a matrix by rows. If it is a vector
with length 2, it means all tracks share the same y-lim.

```{r, fig.width = 10, fig.height = 6}
initialize_layout(track_number = 3, track_ylim = c(0, 3, -4, 4, 0, 1000000))
```

Set y-labels, value of `''` means there is no such y-lab.

```{r, fig.width = 10, fig.height = 6}
initialize_layout(track_number = 3, main = "xxxxxx", track_ylab = c("", "bbbbbb", "ccccccc"))
```

Multiple columns and multiple tracks

```{r, fig.width = 8, fig.height = 12}
initialize_layout(track_number = 3, ncol = 4)
add_cell_info()
```

Do not show border

```{r, fig.width = 8, fig.height = 12}
initialize_layout(track_number = 3, ncol = 4, border = FALSE)
add_cell_info()
```

## Add graphics track by track

Graphics are added by self-defined function `panel.fun`. Similar as **circlize** 
package, `panel.fun` will be applied in every cell in the current track.
The first argument of `add_track` can be either a `GRanges` object or a data frame,
and the argument in `panel.fun` is a subset of data in current chromosome.

```{r, fig.width = 10, fig.height = 6}
library(circlize)
bed = generateRandomBed()
initialize_layout(track_ylim = range(bed[[4]]))
add_track(bed, panel.fun = function(bed) {
    x = (bed[[2]] + bed[[3]]) / 2
    y = bed[[4]]
    grid.points(x, y, pch = 16, size = unit(0.5, "mm"))
})
```

If it is `GRanges` object:

```{r, fig.width = 10, fig.height = 6, message = FALSE}
library(GenomicRanges)
gr = GRanges(seqnames = bed[[1]],
             ranges = IRanges(start = bed[[2]],
                               end = bed[[3]]),
             score = bed[[4]])
initialize_layout(track_ylim = range(bed[[4]]))
add_track(gr, panel.fun = function(gr) {
    x = (start(gr) + end(gr)) / 2
    y = gr$score
    grid.points(x, y, pch = 16, size = unit(0.5, "mm"))
})
```

Initialization and adding graphics are actually independent. Following example uses
same code to add graphics but with different layout.

```{r, fig.width = 8, fig.height = 8}
initialize_layout(nrow = 5, track_ylim = range(bed[[4]]))
add_track(bed, panel.fun = function(bed) {
    x = (bed[[2]] + bed[[3]]) / 2
    y = bed[[4]]
    grid.points(x, y, pch = 16, size = unit(0.5, "mm"))
})
```

In following, we make rainfall plot as well as the density
distribution of genomic regions. Also, we manually add a name track
and an ideogram track.

```{r, fig.width = 8, fig.height = 12}
x = lapply(split(bed, bed[[1]]), function(gr) {
    gr2 = genomicDensity(gr[2:3], window.size = 1e7)
    cbind(rep(gr[1,1], nrow(gr2)), gr2)
})
gd = do.call("rbind", x)
initialize_layout(track_number = 4, ncol = 3,
    track_axis = c(FALSE, TRUE, TRUE, FALSE), 
    track_height = unit.c(1.5*grobHeight(textGrob("chr1")), 
                          unit(1, "null"), 
                          unit(0.5, "null"), 
                          unit(3, "mm")), 
    track_ylim = c(0, 1, 0, 8, c(0, max(gd[[4]])), 0, 1),
    track_ylab = c("", "log10(inter_dist)", "density", ""))
add_track(panel.fun = function(gr){
    chr = get_current_cell_meta_data("name")
    grid.rect(gp = gpar(fill = "#EEEEEE"))
    grid.text(chr)
})
add_track(bed, panel.fun = function(gr) {
    df = rainfallTransform(gr[2:3])
    x = (df[[1]] + df[[2]])/2
    y = log10(df[[3]])
    grid.points(x, y, pch = 16, size = unit(0.5, "mm"))
})
add_track(gd, panel.fun = function(gr) {
    x = (gr[[3]] + gr[[2]])/2
    y = gr[[4]]
    grid.polygon(c(x[1], x, x[length(x)]), 
                 c(0, y, 0), default.units = "native", gp = gpar(fill = "pink"))
})
cytoband_df = read.cytoband()$df
add_track(cytoband_df, panel.fun = function(gr) {
    cytoband_chr = gr
    grid.rect( cytoband_chr[[2]], unit(0, "npc"),
                width = cytoband_chr[[3]] - cytoband_chr[[2]], height = unit(1, "npc"),
                default.units = "native", hjust = 0, vjust = 0,
                gp = gpar(fill = cytoband.col(cytoband_chr[[5]])) )
    grid.rect(min(cytoband_chr[[2]]), unit(0, "npc"),
              width = max(cytoband_chr[[3]]) - min(cytoband_chr[[2]]), height = unit(1, "npc"),
              default.units = "native", hjust = 0, vjust = 0)
})
```

Name track and ideogram track can be added by `add_name_track` and `add_ideogram_track`.
Name track will be inserted before the first track and ideogram track will be 
inserted after the last track.

```{r, fig.width = 8, fig.height = 8}
initialize_layout(nrow = 5, track_ylim = range(bed[[4]]), add_name_track = TRUE, 
    add_ideogram_track = TRUE)
add_track(bed, panel.fun = function(bed) {
    x = (bed[[2]] + bed[[3]]) / 2
    y = bed[[4]]
    grid.points(x, y, pch = 16, size = unit(0.5, "mm"))
})
```

You can also add graphics in specified chromosomes and tracks by specifying `cate`
and `i_track`.

```{r, fig.width = 8, fig.height = 8}
all_chr = paste0("chr", 1:22)
letter = strsplit("MERRY CHRISTMAS!", "")[[1]]
initialize_layout(nrow = 5)
for(i in seq_along(letter)) {
    add_track(cate = all_chr[i], i_track = 1, panel.fun = function(gr) {
        grid.text(letter[i], gp = gpar(fontsize = 30))
    })
}
```

Adding legend is not so straightforward. But you can first create a global viewport
which contains a layout, then put trellis plot in one part and put legend in the
other part. Remember to set `newpage` to `FALSE` so that trellis plot will be
added on the current graphic device.

```{r, fig.width = 8, fig.height = 8}
legd = legendGrob("label", pch = 16)
layout = grid.layout(nrow = 1, ncol = 2, widths = unit.c(unit(1, "null"), grobWidth(legd)))
grid.newpage()
pushViewport(viewport(layout = layout))

pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 1))
initialize_layout(nrow = 5, track_ylim = range(bed[[4]]), newpage = FALSE)
add_track(bed, panel.fun = function(bed) {
    x = (bed[[2]] + bed[[3]]) / 2
    y = bed[[4]]
    grid.points(x, y, pch = 16, size = unit(0.5, "mm"))
})
upViewport()

pushViewport(viewport(layout.pos.row = 1, layout.pos.col = 2))
grid.draw(legd)
upViewport()

```

Following code plot coverage for a tumor, its companion normal sample
and the ratio of coverage.

```{r, fig.width = 14, fig.height = 14}
tumor_df = read.table("/icgc/dkfzlsdf/analysis/hipo/hipo_047/whole_genome_sequencing/H047-AV6G/coverage/tumor_H047-AV6G_1kb_windows_sorted.txt.gz")
tumor_df = data.frame(chr = paste0("chr", tumor_df[[1]]),
                      start = tumor_df[[2]],
                      end = tumor_df[[2]] + 1000,
                      cov = tumor_df[[3]])
normal_df = read.table("/icgc/dkfzlsdf/analysis/hipo/hipo_047/whole_genome_sequencing/H047-AV6G/coverage/control_H047-AV6G_1kb_windows_sorted.txt.gz")
normal_df = data.frame(chr = paste0("chr", normal_df[[1]]),
                      start = normal_df[[2]],
                      end = normal_df[[2]] + 1000,
                      cov = normal_df[[3]])

# remove regions that have zero coverage
ind = which(tumor_df$cov > 0 & normal_df$cov > 0)
tumor_df = tumor_df[ind, , drop = FALSE]
normal_df = normal_df[ind, , drop = FALSE]
ratio_df = tumor_df
q01 = quantile(c(tumor_df$cov, normal_df$cov), 0.01)
ratio_df[[4]] = log2( (tumor_df$cov+q01) / (normal_df$cov+q01) )
names(ratio_df) = c("chr", "start", "end", "ratio")
tumor_df[[4]] = log10(tumor_df[[4]])
normal_df[[4]] = log10(normal_df[[4]])

cov_range = range(c(tumor_df[[4]], normal_df[[4]]))
ratio_range = range(ratio_df[[4]])
ratio_range = c(-max(abs(ratio_range)), max(abs(ratio_range)))

initialize_layout(track_number = 3, nrow = 2, byrow = FALSE, gap = unit(c(4, 1), "mm"),
    track_ylim = c(cov_range, cov_range, ratio_range),
    track_ylab = c("tumor, log10(cov)", "normal, log10(cov)", "ratio, log2(ratio)"), 
    add_name_track = TRUE, add_ideogram_track = TRUE)
add_track(tumor_df, panel.fun = function(gr) {
    x = (gr[[2]] + gr[[3]])/2
    y = gr[[4]]
    grid.points(x, y, pch = 16, size = unit(2, "bigpts"), gp = gpar(col = "#00000020"))
})
add_track(normal_df, panel.fun = function(gr) {
    x = (gr[[2]] + gr[[3]])/2
    y = gr[[4]]
    grid.points(x, y, pch = 16, size = unit(2, "bigpts"), gp = gpar(col = "#00000020"))
})
add_track(ratio_df, panel.fun = function(gr) {
    x = (gr[[2]] + gr[[3]])/2
    y = gr[[4]]
    grid.points(x, y, pch = 16, size = unit(2, "bigpts"), gp = gpar(col = "#FF000020"))
})
```

Following figure is kind of karyogram view of genomic regions. We arrange the layout as 
one column and create two tracks, one for genomic regions and one for ideogram.
Different values are mapped to continuous colors.

```{r, fig.width = 8, fig.height = 8}
bed = generateRandomBed(nr = 10000)
bed = bed[sample(10000, 100), ]
col_fun = colorRamp2(c(-1, 0, 1), c("green", "yellow", "red"))
initialize_layout(track_number = 1, ncol = 1, track_axis = FALSE, xpadding = c(0.1, 0),
    gap = unit(4, "mm"), border = FALSE, add_ideogram_track = TRUE, 
    ideogram_track_height = unit(2, "mm"))
add_track(bed, clip = FALSE, panel.fun = function(gr) {
    grid.rect((gr[[2]] + gr[[3]])/2, unit(0.2, "npc"), unit(1, "mm"), unit(0.8, "npc"), 
        hjust = 0, vjust = 0, default.units = "native", 
        gp = gpar(fill = col_fun(gr[[4]]), col = NA))    
})
add_track(i_track = 2, clip = FALSE, panel.fun = function(gr) {
    chr = get_current_cell_meta_data("name")
    if(chr == "chrY") {
        grid.lines(get_current_cell_meta_data("xlim"), unit(c(0, 0), "npc"), 
            default.units = "native")
    }
    grid.text(chr, x = 0, y = 0, just = c("left", "bottom"))
})
breaks = seq(-1, 1, by = 0.5)
lg = legendGrob(breaks, pch = 15, vgap = 0, gp = gpar(col = col_fun(breaks)))
pushViewport(viewport(0.9, 0.1, width = grobWidth(lg), height = grobHeight(lg), just = c(1, 0)))
grid.draw(lg)
upViewport()
```

## General genomic categories

Genomic categoris are not restricted in chromosomes, it can be any kind
such as genes. Similar as `circos.genomicInitialize`, you can also specify
genomic categories as well as their ranges as a data frame when you 
initialize the layout. 

In following example, we put three genes in one row and add their transcripts.

```{r, fig.width = 10, fig.height = 3}
load(paste0(system.file(package = "circlize"), "/extdata/tp_family.RData"))
df = data.frame(gene = names(tp_family),
    start = sapply(tp_family, function(x) min(unlist(x))),
    end = sapply(tp_family, function(x) max(unlist(x))))
n = max(sapply(tp_family, length))
initialize_layout(data = df, track_number = 1, track_ylim = c(0.5, n+0.5), 
    track_axis = FALSE, add_name_track = TRUE, xpadding = c(0.05, 0.05), ypadding = c(0.05, 0.05))
add_track(panel.fun = function(gr) {
    gn = get_current_cell_meta_data("name")
    tr = tp_family[[gn]] # all transcripts for this gene
    for(i in seq_along(tr)) {
        # for each transcript
        current_tr_start = min(tr[[i]]$start)
        current_tr_end = max(tr[[i]]$end)
        grid.lines(c(current_tr_start, current_tr_end), c(n - i + 1, n - i + 1), 
            default.units = "native", gp = gpar(col = "#CCCCCC"))
        grid.rect(tr[[i]][[1]], n - i + 1, tr[[i]][[2]] - tr[[i]][[1]], 0.8,
            default.units = "native", just = "left", 
            gp = gpar(fill = "orange", col = "orange"))
    }
})
```

If you want to put all genes on one column and align them by TSS, you first need 
to transform the genomic coordinate.

```{r}
tp_family$TP53 = lapply(tp_family$TP53, function(df) {
        data.frame(start = 7590863 - df[[2]],
                   end = 7590863 - df[[1]])
    })
tp_family$TP63 = lapply(tp_family$TP63, function(df) {
        data.frame(start = df[[1]] - 189349205,
                   end = df[[2]] - 189349205)
    })
tp_family$TP73 = lapply(tp_family$TP73, function(df) {
        data.frame(start = df[[1]] - 3569084,
                   end = df[[2]] - 3569084)
    })
```

Then similar code as previous one.

```{r, fig.width = 8, fig.height = 6}
df = data.frame(gene = names(tp_family),
    start = sapply(tp_family, function(x) min(unlist(x))),
    end = sapply(tp_family, function(x) max(unlist(x))))
n = max(sapply(tp_family, length))
initialize_layout(data = df, track_number = 1, ncol = 1, track_ylim = c(0.5, n+0.5), 
    track_axis = FALSE, add_name_track = TRUE, 
    xpadding = c(0.01, 0.01), ypadding = c(0.05, 0.05))
add_track(panel.fun = function(gr) {
    gn = get_current_cell_meta_data("name")
    tr = tp_family[[gn]] # all transcripts for this gene
    for(i in seq_along(tr)) {
        # for each transcript
        current_tr_start = min(tr[[i]]$start)
        current_tr_end = max(tr[[i]]$end)
        grid.lines(c(current_tr_start, current_tr_end), c(n - i + 1, n - i + 1), 
            default.units = "native", gp = gpar(col = "#CCCCCC"))
        grid.rect(tr[[i]][[1]], n - i + 1, tr[[i]][[2]] - tr[[i]][[1]], 0.8,
            default.units = "native", just = "left", 
            gp = gpar(fill = "orange", col = "orange"))
    }
})
```

Also you can create layout with self-defined regions. `clip` argument controls whether
data points out of the cell need to be added. Since by default `clip` is `TRUE`, 
you do need to make intersection of your full data to the sub-region, which means, you
can use same graphics codes with different regions. 

```{r, fig.width = 10, fig.height = 8}
zoom = function() {
	initialize_layout(data = df, track_number = 3, nrow = 2,
    track_ylim = c(cov_range, cov_range, ratio_range),
    track_ylab = c("tumor, log10(cov)", "normal, log10(cov)", "ratio, log2(ratio)"), 
    add_name_track = TRUE, add_ideogram_track = TRUE)
	add_track(tumor_df, panel.fun = function(gr) {
	    x = (gr[[2]] + gr[[3]])/2
	    y = gr[[4]]
	    grid.points(x, y, pch = 16, size = unit(2, "bigpts"), gp = gpar(col = "#00000080"))
	})
	add_track(normal_df, panel.fun = function(gr) {
	    x = (gr[[2]] + gr[[3]])/2
	    y = gr[[4]]
	    grid.points(x, y, pch = 16, size = unit(2, "bigpts"), gp = gpar(col = "#00000080"))
	})
	add_track(ratio_df, panel.fun = function(gr) {
	    x = (gr[[2]] + gr[[3]])/2
	    y = gr[[4]]
	    grid.points(x, y, pch = 16, size = unit(2, "bigpts"), gp = gpar(col = "#FF000080"))
	})
}

df = data.frame(chr = c("chr1", "chr2"),
                start = c(1e7, 1e7),
                end = c(2e7, 2e7))
zoom()

df = data.frame(chr = c("chr11", "chr12"),
                start = c(4e7, 4e7),
                end = c(8e7, 8e7))
zoom()
```

If x-ranges for two genomic categories are different (e.g. 0~100000 for the first one
and 100000~200000 for the second one), you should not put them in a same column (which
means `nrow` can only be 1).
